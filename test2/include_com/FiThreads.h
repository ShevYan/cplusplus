#pragma once
#include "libcfg.h"
#include "difstypes.h"
#include "OSThread.h"
#include "FiContext.h"
#include "md5.h"
#include "fitimer.h"
#include "FiLog.h"
#include "FiDict.h"
#include "FiErr.h"
#include "error_def.h"

using namespace std;

int fi_create_thread(pthread_t *__newthread, void* (*start)(void *), void *__arg);

typedef void (*FiThreadPfn)(int, void *);

template<typename _Tp>
class FiListIt {
public:
        FiListIt() {
                m_bNull = true;
                m_pTpList = NULL;
        }

        ~FiListIt() {
                m_bNull = true;
        }

        void Set(typename list<_Tp>::iterator& it) {
                m_it = it;
                m_bNull = false;
        }

        void UnSet() {
                m_bNull = true;
        }

        typename list<_Tp>::iterator& It() {
                return m_it;
        }

        bool IsNull() {
                return m_bNull;
        }

        void PushBack(list<_Tp>& tpList, _Tp& value) {
                assert(IsNull());
                tpList.push_back(value);
                m_it = tpList.end();
                m_it--;
                m_pTpList = &tpList;
                m_bNull = false;
        }

        void Erase() {
                assert(!IsNull() && NULL != m_pTpList);
                m_pTpList->erase(m_it);
                m_pTpList = NULL;
                m_bNull = true;
        }

private:
        bool                m_bNull;
        typename list<_Tp>::iterator m_it;
        list<_Tp> *m_pTpList;
};

struct FiThreadTask {
        u64 nTaskId;
        void *pContext;
        FiThreadPfn pfnCallBack;
        FiEvent *pEvent;
        bool bMerged;
        bool bDelContextAfterMerge;

        FiListIt<FiThreadTask *> itInTaskList;
        FiListIt<FiThreadTask *> itInWaitTaskList;
        FiListIt<FiThreadTask *> itInTaskIdMapList;

        void clone(FiThreadTask *pTask) {
                nTaskId = pTask->nTaskId;
                pContext = pTask->pContext;
                pfnCallBack = pTask->pfnCallBack;
                pEvent = pTask->pEvent;
                bMerged = pTask->bMerged;
                bDelContextAfterMerge = pTask->bDelContextAfterMerge;
        }
};

struct FtBusyTaskWaitUnit {
        u64         nTaskId;
        FiEvent *pEvent;
};

/**
 * ???
 * 1. ?????????????id
 * 2. ????????????????????????2? ???ThreadNumPerTask
 * 3. ????????????10? ????MaxThreadNum
 * 4. ?????????????????????????????????
 * 5. ???????????????????????????????????id??????id??????PushMergedTask
 * 6. ????????id??????????????100?? ????MaxTaskEntryNum?
 * 7. ?????????????????????1000??????MaxTaskNum?
 * 8. ????clear?????????
 * 9. ??FiThreads???????????????????????????/ParentRoot/FiThreads
 */
class FiThreads {

private:
        /**
         * pushtask,???????
         */
        list<FiThreadTask *>            m_taskList;
        /**
         * ????taskid???????taskid????
         */
        map<u64, list<FiThreadTask*> >  m_taskidToWaitTaskMap;
        /**
         * ????????callback?????????????????
         */
        map<u64, list<FiThreadTask*> >  m_taskidToTaskMap;
        /**
         * ?taskid?key??????map
         */
        map<u64, FiThreadTask *>        m_taskidToMegeredTaskMap;

        /**
         * ?????????????clear????
         */
        map<u64, list<FtBusyTaskWaitUnit*> >  m_busyTaskIdToWaiters;
        /**
         * ????????taskid???
         */
        map<u64, u64>                   m_busyTaskIdToBusyNum;
        /**
         * ??????????set
         */
        set<pthread_t>                  m_hThreadSet;

        map<u64, u32>                   m_nSpecTaskIdToMaxThreadNumMap;

        CCritSec                        m_lock;
        FiSem                           m_sem;
        u64                             m_nTaskNum;
        CFiContext *m_pFiCxt;
        string                          m_strConfigPath;
        u64                             m_nThreadNum;
        u64                             m_nDefaultMaxThreadNumPerTask;
        u64                             m_nDefaultMaxTaskNum;
        u64                             m_nDefaultMaxTaskEntryNum;
        FiThreadPfn                     m_pfnDefaultCallBack;

        bool                            m_bRun;
        bool                            m_bPauseReceiveTask;

        FiEvent                         m_waitAllTaskFinish;
        int                             m_nWaitAllTaskFinishTimerId;

public:
        FiThreads();

        /**
         * ??????????????????????????????????????????????WaitAllTaskFinish? ????????????????PauseReceiveTask
         * ?????
         * ??????????fithread??????????????????(????????????????)? ????????????WaitAllTaskFinish?
         * ???fithread?????????fithread?????????????????????OnTaskProc??????????fithread????????????
         * ????????fithread?onTaskProc????????????
         */
        virtual ~FiThreads();

        FiErr PushTask(u64 nTaskId, void *pContext = NULL, FiThreadPfn pfnCallBack = NULL, FiEvent *pEvent = NULL);

        FiErr PushMergedTask(u64 nTaskId, void *pContext = NULL, FiThreadPfn pfnCallBack = NULL, bool bDelContextAfterMerge = false);

        void  ClearTask(u64 nTaskId, bool bWait = true);

        void  Run();

        virtual void OnTaskProc(u64 nTaskId, void *pPara);

        void  SetMaxTaskNum(u64 nMaxTaskNum, u64 nMaxTaskEntryNum);

        void  SetMaxThreadNum(u32 nMaxThreadNum);

        void  SetMaxThreadNumPerTask(u32 nMaxThreadNumPerTask);

        void  SetMaxThreadNumForSpecificTask(u64 nTaskId, u32 nMaxThreadNumPerTask);

        void  SetConfigPath(string strConfigPath);

        void  SetDefaultCallBack(FiThreadPfn pfnCallBack);

        /**
         * ??????????????????????????PauseReceiveTask????
         */
        void  WaitAllTaskFinish();

        void  OnTimerCheckTaskFinish(int nTimerId);

        /**
         * fithread????????????????????????
         */
        void PauseReceiveTask() {
                m_lock.Lock();
                m_bPauseReceiveTask = true;
                m_lock.Unlock();
        }

        /**
         * fithread????????????????????????????????????Run????????????????
         */
        void StartReceiveTask() {
                m_lock.Lock();
                m_bPauseReceiveTask = false;
                m_lock.Unlock();
        }

private:
        static void PfnTimerCheckTaskFinish(int nTimerId, void *pParam) {
                FiThreads *pFiThread = (FiThreads *)pParam;
                pFiThread->OnTimerCheckTaskFinish(nTimerId);
        }

        static void* ThreadFunc(void *pPara);

        FiErr PushTask(FiThreadTask *pTask, bool& bRefTask);

        void DeleteTask(FiThreadTask *pTask);

        void TaskProc();

        void ClearAllTaskWhenDestruct();

        u32 GetMaxThreadNumForTask(u64 nTaskId);
};


/**
 * ???
 * 1. ?????????????id
 * 2. ????????????????????????2, ???ThreadNumPerTask?????????????
 * 3. ????????????10?????MaxThreadNum????????????
 * 4. ?????????????????????????????????
 * 5. ???????????????????????????????????id??????id??????PushMergedTask
 * 6. ????????id??????????????100??????MaxTaskEntryNum?????????????
 * 7. ?????????????????????1000??????MaxTaskNum?????????????
 * 8. ????clear?????????
 * 9. ???????/FiConfig/FiThreads
 */
class FiWorkerQueue {

private:
        FiThreads m_threadPool;
        static CCritSec s_lock;
        static FiWorkerQueue *volatile s_pInstance;

public:
        static FiWorkerQueue* GetInstance();

        FiErr PushTask(u64 nTaskId, FiThreadPfn pfnCallBack, void *pContext = NULL, FiEvent *pEvent = NULL);

        FiErr PushMergedTask(u64 nTaskId, FiThreadPfn pfnCallBack, void *pContext = NULL, bool bDelContextAfterMerge = false);

        void  ClearTask(u64 nTaskId, bool bWait = true);

        ~FiWorkerQueue();

private:
        FiWorkerQueue();

};
